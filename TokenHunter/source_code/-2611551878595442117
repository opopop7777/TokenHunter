{"P3XGamesHub.sol":{"content":"pragma solidity 0.5.10;\r\n\r\nimport \"./SafeMath.sol\";\r\n\r\ncontract P3XGamesHub {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    function()\r\n        external\r\n        payable\r\n    {}\r\n    \r\n    //\r\n    //Players\r\n    //\r\n    \r\n    struct Player {\r\n        uint256 balance;\r\n        uint256 fundingBalance;\r\n    }\r\n    \r\n    mapping(address =\u003e Player) public players;\r\n    uint256 public totalPlayerBalances;\r\n    uint256 public totalFundingBalances;\r\n    \r\n    event Withdraw(address indexed player, uint256 amount);\r\n    event Fund(address indexed funder, uint256 amount);\r\n    event WithdrawFunding(address indexed player, uint256 amount);\r\n\t\r\n\tfunction fund(address player, uint256 amount)\r\n\t    private\r\n\t{\r\n\t    players[player].fundingBalance = players[player].fundingBalance.add(amount);\r\n\t    \r\n\t    totalFundingBalances += amount;\r\n\t    \r\n\t    emit Fund(player, amount);\r\n\t}\r\n\t\r\n\tfunction playGame(address player, uint256 amount, bytes memory data)\r\n\t    private\r\n\t{\r\n\t    (address gameAddress, bytes memory gameData) = abi.decode(data, (address, bytes));\r\n\t    \r\n\t    require(games[gameAddress].registered);\r\n\t    \r\n\t    games[gameAddress].amountGiven += amount;\r\n\t    \r\n\t    IHubGame(gameAddress).play(player, amount, gameData);\r\n\t}\r\n\t\r\n\tfunction withdrawBalance()\r\n\t    external\r\n\t    fetchP3XDividends\r\n\t{\r\n\t    uint256 amount = players[msg.sender].balance;\r\n\t    \r\n\t    require(amount \u003e 0);\r\n\t    \r\n\t    players[msg.sender].balance = 0;\r\n\t    \r\n\t    totalPlayerBalances -= amount;\r\n\t    \r\n        p3xContract.transfer(msg.sender, amount);\r\n        \r\n\t    emit Withdraw(msg.sender, amount);\r\n\t}\r\n\t\r\n\tfunction withdrawBalancePartial(uint256 howMuch)\r\n\t    external\r\n\t    fetchP3XDividends\r\n\t{\r\n\t    require(howMuch \u003e 0);\r\n\t    \r\n\t    players[msg.sender].balance = players[msg.sender].balance.sub(howMuch);\r\n\t    \r\n\t    totalPlayerBalances -= howMuch;\r\n\t   \r\n        p3xContract.transfer(msg.sender, howMuch);\r\n\t    \r\n\t    emit Withdraw(msg.sender, howMuch);\r\n\t}\r\n\t\r\n\tfunction withdrawFundingBalance()\r\n\t    external\r\n\t{\r\n\t    uint256 amount = players[msg.sender].fundingBalance;\r\n\t    \r\n\t    require(amount \u003e 0);\r\n\t    \r\n\t    players[msg.sender].fundingBalance = 0;\r\n\t    \r\n\t    totalFundingBalances -= amount;\r\n\t   \r\n\t    p3xContract.transfer(msg.sender, amount);\r\n\t    \r\n\t    emit WithdrawFunding(msg.sender, amount);\r\n\t}\r\n\t\r\n\tfunction withdrawFundingBalancePartial(uint256 howMuch)\r\n\t    external\r\n\t{\r\n\t    require(howMuch \u003e 0);\r\n\t    \r\n\t    players[msg.sender].fundingBalance = players[msg.sender].fundingBalance.sub(howMuch);\r\n\t    \r\n\t    totalFundingBalances -= howMuch;\r\n\t   \r\n\t    p3xContract.transfer(msg.sender, howMuch);\r\n\t    \r\n\t    emit WithdrawFunding(msg.sender, howMuch);\r\n\t}\r\n\t\r\n\t//\r\n\t//Games\r\n\t//\r\n\t\r\n\tstruct Game {\r\n        bool registered;\r\n        uint256 amountGiven;\r\n        uint256 amountTaken;\r\n    }\r\n    \r\n    mapping(address =\u003e Game) public games;\r\n    uint256 public numberOfGames;\r\n\t\r\n\taddress public manager = address(0x1EB2acB92624DA2e601EEb77e2508b32E49012ef);\r\n\taddress public newManager = address(0);\r\n    \r\n    event AddGame(address game);\r\n    event RemoveGame(address game);\r\n    \r\n    modifier isRegisteredGame(address gameAddress)\r\n    {\r\n        require(games[gameAddress].registered);\r\n        _;\r\n    }\r\n    \r\n    modifier isUnregisteredGame(address gameAddress)\r\n    {\r\n        require(!games[gameAddress].registered);\r\n        _;\r\n    }\r\n\r\n    modifier onlyManager()\r\n    {\r\n        require(msg.sender == manager);\r\n        _;\r\n    }\r\n\r\n    function addGame(address gameAddress)\r\n        external\r\n        onlyManager\r\n        isUnregisteredGame(gameAddress)\r\n    {\r\n        games[gameAddress] = Game(true, 0, 0);\r\n        numberOfGames++;\r\n        \r\n        emit AddGame(gameAddress);\r\n    }\r\n    \r\n    function removeGame(address gameAddress)\r\n        external\r\n        onlyManager\r\n        isRegisteredGame(gameAddress)\r\n    {\r\n        games[gameAddress].registered = false;\r\n        numberOfGames--;\r\n        \r\n        emit RemoveGame(gameAddress);\r\n    }\r\n    \r\n    function changeManager(address newManagerAddress)\r\n        external\r\n        onlyManager\r\n    {\r\n        newManager = newManagerAddress;\r\n    }\r\n    \r\n    function becomeManager()\r\n        external\r\n    {\r\n        require(msg.sender == newManager);\r\n        manager = newManager;\r\n        newManager = address(0);\r\n    }\r\n\t\r\n\tfunction addPlayerBalance(address playerAddress, uint256 value)\r\n\t    external\r\n\t    isRegisteredGame(msg.sender)\r\n\t{\r\n\t    addPlayerBalanceInternal(msg.sender, playerAddress, value);\r\n\t}\r\n\t\r\n\tfunction addPlayerBalances(address[] calldata playerAddresses, uint256[] calldata values)\r\n\t    external\r\n\t    isRegisteredGame(msg.sender)\r\n\t{\r\n\t    for(uint256 i = 0; i \u003c playerAddresses.length; i++) {\r\n\t        addPlayerBalanceInternal(msg.sender, playerAddresses[i], values[i]);\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction addPlayerBalanceInternal(address gameAddress, address playerAddress, uint256 value)\r\n\t    private\r\n\t{\r\n\t    players[playerAddress].balance = players[playerAddress].balance.add(value);\r\n\t    games[gameAddress].amountTaken += value;\r\n\t    \r\n\t    totalPlayerBalances += value;\r\n\t}\r\n\t\r\n\tfunction subPlayerBalance(address playerAddress, uint256 value)\r\n\t    external\r\n\t    isRegisteredGame(msg.sender)\r\n\t{\r\n\t    subPlayerBalanceInternal(msg.sender, playerAddress, value);\r\n\t}\r\n\t\r\n\tfunction subPlayerBalances(address[] calldata playerAddresses, uint256[] calldata values)\r\n\t    external\r\n\t    isRegisteredGame(msg.sender)\r\n\t{\r\n\t    for(uint256 i = 0; i \u003c playerAddresses.length; i++) {\r\n\t        subPlayerBalanceInternal(msg.sender, playerAddresses[i], values[i]);\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction subPlayerBalanceInternal(address gameAddress, address playerAddress, uint256 value)\r\n\t    private\r\n\t{\r\n\t    players[playerAddress].balance = players[playerAddress].balance.sub(value);\r\n\t    games[gameAddress].amountGiven += value;\r\n\t    \r\n\t    totalPlayerBalances -= value;\r\n\t}\r\n\t\r\n\t//\r\n\t// P3X Integration\r\n\t//\r\n\t\r\n\taddress constant private P3X_ADDRESS = address(0x058a144951e062FC14f310057D2Fd9ef0Cf5095b);\r\n    IP3X constant private p3xContract = IP3X(P3X_ADDRESS);\r\n    \r\n    modifier onlyP3X()\r\n    {\r\n        require(msg.sender == P3X_ADDRESS);\r\n        _;\r\n    }\r\n\t\r\n\tmodifier fetchP3XDividends()\r\n    {\r\n        if(totalSupply \u003e 0) {\r\n            uint256 dividends = p3xContract.dividendsOf(address(this), true);\r\n            if(dividends \u003e 0) {\r\n                uint256 contractBalance = address(this).balance;\r\n                p3xContract.withdraw();\r\n                uint256 newContractBalance = address(this).balance;\r\n                uint256 actualDividends = newContractBalance.sub(contractBalance);\r\n                totalDividendPoints = totalDividendPoints.add(actualDividends.mul(POINT_MULTIPLIER) / totalSupply);\r\n                totalOutstandingDividends = totalOutstandingDividends.add(actualDividends);\r\n            }\r\n        }\r\n        _;\r\n    }\r\n    \r\n    function tokenFallback(address player, uint256 amount, bytes calldata data)\r\n\t    external\r\n\t    onlyP3X\r\n\t    fetchP3XDividends\r\n\t{\r\n\t    require(amount \u003e 0);\r\n\t    \r\n\t    if(data.length == 0) {\r\n\t        fund(player, amount);\r\n\t    } else {\r\n\t        playGame(player, amount, data);\r\n\t    }\r\n\t}\r\n    \r\n    //\r\n    //Shareholder Setup\r\n\t//\r\n\t\r\n    struct Shareholder {\r\n        uint256 tokens;\r\n        uint256 outstandingDividends;\r\n        uint256 lastDividendPoints;\r\n    }\r\n\r\n    uint256 public totalSupply = 0;\r\n    mapping(address =\u003e Shareholder) public shareholders;\r\n    \r\n    uint256 constant private POINT_MULTIPLIER = 10e18;\r\n    uint256 private totalDividendPoints;\r\n    uint256 public totalOutstandingDividends;\r\n    \r\n    event Mint(address indexed player, uint256 indexed amount);\r\n    \r\n    function addShareholderTokens(address playerAddress, uint256 amount)\r\n        external\r\n\t    isRegisteredGame(msg.sender)\r\n    {\r\n        updateOutstandingDividends(shareholders[playerAddress]);\r\n        shareholders[playerAddress].tokens = shareholders[playerAddress].tokens.add(amount);\r\n        \r\n        totalSupply += amount;\r\n        \r\n        emit Mint(playerAddress, amount);\r\n    }\r\n    \r\n    function updateOutstandingDividends(Shareholder storage shareholder)\r\n        private\r\n    {\r\n        uint256 dividendPointsDifference = totalDividendPoints.sub(shareholder.lastDividendPoints);\r\n        \r\n        shareholder.lastDividendPoints = totalDividendPoints;\r\n        shareholder.outstandingDividends = shareholder.outstandingDividends\r\n                                            .add(dividendPointsDifference.mul(shareholder.tokens) / POINT_MULTIPLIER);\r\n    }\r\n    \r\n    function withdrawDividends()\r\n        external\r\n    {\r\n        Shareholder storage shareholder = shareholders[msg.sender];\r\n        \r\n        updateOutstandingDividends(shareholder);\r\n        \r\n        uint256 amount = shareholder.outstandingDividends;\r\n        \r\n        require(amount \u003e 0);\r\n        \r\n        shareholder.outstandingDividends = 0;\r\n        totalOutstandingDividends = totalOutstandingDividends.sub(amount);\r\n\t\t\r\n\t    msg.sender.transfer(amount);\r\n    }\r\n}\r\n\r\ninterface IP3X {\r\n    function transfer(address to, uint256 value) external returns(bool);\r\n\tfunction dividendsOf(address customerAddress, bool includeReferralBonus) external view returns(uint256);\r\n    function withdraw() external;\r\n}\r\n\r\ninterface IHubGame {\r\n    function play(address playerAddress, uint256 value, bytes calldata gameData) external;\r\n}"},"SafeMath.sol":{"content":"pragma solidity 0.5.10;\r\n\r\nlibrary SafeMath {\r\n    \r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b \u003c= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n    \r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c \u003e= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n}"}}