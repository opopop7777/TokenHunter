{"Container.sol":{"content":"pragma solidity ^0.5.11;\n\ncontract Container{\n    struct Item{\n        uint256 itemType;\n        uint256 status;\n        address[] addresses;\n    }\n    uint256 MaxItemAdressNum = 255;\n\n    mapping (bytes32 =\u003e Item) private container;\n\n    function itemAddressExists(bytes32 id, address oneAddress) internal view returns(bool){\n        for(uint256 i = 0; i \u003c container[id].addresses.length; i++){\n            if(container[id].addresses[i] == oneAddress)\n                return true;\n        }\n        return false;\n    }\n    function getItemAddresses(bytes32 id) internal view returns(address[] memory){\n        return container[id].addresses;\n    }\n\n    function getItemInfo(bytes32 id) internal view returns(uint256, uint256, uint256){\n        return (container[id].itemType, container[id].status, container[id].addresses.length);\n    }\n\n    function getItemAddressCount(bytes32 id) internal view returns(uint256){\n        return container[id].addresses.length;\n    }\n\n    function setItemInfo(bytes32 id, uint256 itemType, uint256 status) internal{\n        container[id].itemType = itemType;\n        container[id].status = status;\n    }\n\n    function addItemAddress(bytes32 id, address oneAddress) internal{\n        require(!itemAddressExists(id, oneAddress), \"dup address added\");\n        require(container[id].addresses.length \u003c MaxItemAdressNum, \"too many addresses\");\n        container[id].addresses.push(oneAddress);\n    }\n    function removeItemAddresses(bytes32 id) internal{\n        container[id].addresses.length = 0;\n    }\n\n    function removeOneItemAddress(bytes32 id, address oneAddress) internal{\n        for(uint256 i = 0; i \u003c container[id].addresses.length; i++){\n            if(container[id].addresses[i] == oneAddress){\n                container[id].addresses[i] = container[id].addresses[container[id].addresses.length - 1];\n                container[id].addresses.length--;\n                return;\n            }\n        }\n        revert(\"not exist address\");\n    }\n\n    function removeItem(bytes32 id) internal{\n        delete container[id];\n    }\n\n    function replaceItemAddress(bytes32 id, address oneAddress, address anotherAddress) internal{\n        require(!itemAddressExists(id,anotherAddress),\"dup address added\");\n        for(uint256 i = 0; i \u003c container[id].addresses.length; i++){\n            if(container[id].addresses[i] == oneAddress){\n                container[id].addresses[i] = anotherAddress;\n                return;\n            }\n        }\n        revert(\"not exist address\");\n    }\n}"},"HBTCStorage.sol":{"content":"pragma solidity ^0.5.11;\n\nimport \"./Container.sol\";\n\ncontract HBTCStorage is Container{\n\n    string public constant name = \"HBTCStorage\";\n\n    address private caller;\n\n    constructor(address aCaller) public{\n        totalSupply = 0;\n        caller = aCaller;\n    }\n    uint256 public totalSupply;\n\n    mapping (address =\u003e uint256) private balances;\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private allowed;\n\n    function supporterExists(bytes32 taskHash, address user) public view returns(bool){\n        return itemAddressExists(taskHash, user);\n    }\n\n    function setTaskInfo(bytes32 taskHash, uint256 taskType, uint256 status) external onlyCaller{\n        setItemInfo(taskHash, taskType, status);\n    }\n\n    function getTaskInfo(bytes32 taskHash) public view returns(uint256, uint256, uint256){\n        return getItemInfo(taskHash);\n    }\n\n    function addSupporter(bytes32 taskHash, address oneAddress) external onlyCaller{\n        addItemAddress(taskHash, oneAddress);\n    }\n\n    function removeAllSupporter(bytes32 taskHash) external onlyCaller{\n        removeItemAddresses(taskHash);\n    }\n\n    modifier onlyCaller() {\n        require(msg.sender == caller, \"only use main main contract to call\");\n        _;\n    }\n\n    function getTotalSupply() external view returns(uint256) {\n        return totalSupply;\n    }\n\n    function setTotalSupply(uint256 amount) external onlyCaller {\n        totalSupply = amount;\n    }\n\n    function balanceOf(address account) external view returns(uint256) {\n        return balances[account];\n    }\n\n    function setBalance(address account,uint256 amount) external onlyCaller {\n        require(account != address(0),\"account address error\");\n        balances[account] = amount;\n    }\n\n    function getAllowed(address owner,address spender) external view returns(uint256) {\n        return allowed[owner][spender];\n    }\n\n    function setAllowed(address owner,address spender,uint256 amount) external onlyCaller {\n        require(owner != address(0),\"owner address error\");\n        require(spender != address(0),\"spender address error\");\n        allowed[owner][spender] = amount;\n    }\n}"}}