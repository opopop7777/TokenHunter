{"FoundingTeam.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./TripioToken.sol\";\nimport \"./Owned.sol\";\n\ncontract FoundingTeam is Owned {\n\n    // Team with 4 members\n    struct Team {\n        address m0;\n        address m1;\n        address m2;\n        address m3;\n    }\n\n    struct Proposal {\n        address sponsor;\n        mapping(address =\u003e bool) signatures;\n        uint256 timestamp;\n        uint8 proposalType;\n    }\n\n    uint256 public proposalLength = 0;\n\n    // decisions,all proposals are indexed by decisionIndex\n    mapping(uint256 =\u003e Proposal) public proposalMap;\n\n    mapping (uint256 =\u003e mapping (address =\u003e uint16)) public suggestedPercentagesMap;\n    mapping (uint256 =\u003e Team) public suggestedTeamMap;\n    mapping (uint256 =\u003e uint8) public suggestStatusMap; \n    mapping (uint256 =\u003e bool) public suggestTerminalMap;\n\n    Team team;\n\n    // TRIO contract \n    TripioToken tripio;\n\n    // Percentage of funds\n    mapping(address =\u003e uint16) percentages;\n\n    // Enable \n    bool public enabled;\n\n    address public fundingSource;\n\n    // Timestamps\n    uint256[] timestamps;\n\n    // proposalType == 1\n    event PercentagesProposalMade(address _sponsor, uint256 _timestamp, uint16 _m0P, uint16 _m1P, uint16 _m2P, uint16 _m3P);\n\n    // proposalType == 2\n    event MembersProposalMade(address _sponsor, uint256 _timestamp, address _m0, address _m1, address _m2, address _m3);\n\n    // proposalType == 3\n    event StatusProposalMade(address _sponsor, uint256 _timestamp, uint8 _status);\n\n    // proposalType == 4\n    event TerminalProposalMade(address _sponsor, uint256 _timestamp, bool _terminal);\n\n    event Vote(address _voter, uint256 _proposalIndex);\n    /**\n     * This emits when deposited\n     */\n    event Deposited(address _owner, uint256 _value);\n\n    /**\n     * This emits when percentages updated\n     */\n    event PercentagesUpdated(uint16 _m0, uint16 _m1, uint16 _m2, uint16 _m3);\n\n    /**\n     * This emits when members updated\n     */\n    event MembersUpdated(address _m0, address _m1, address _m2, address _m3);\n    \n    /**\n     * This emits when status updated\n     */\n    event StatusUpdated(uint8 _status);\n\n    /**\n     * This emits when terminated\n     */\n    event Terminated();\n\n    /**\n     * This emits when candied\n     */\n    event Candy();\n\n    /**\n     * @dev Constructor \n     * @param _m0 Team member 0 has 44% found\n     * @param _m1 Team member 1 has 25% found\n     * @param _m2 Team member 2 has 18.6% found\n     * @param _m3 Team member 3 has 12.4% found \n     * @param _trio TRIO contract address\n     */\n    constructor(address _m0, address _m1, address _m2, address _m3, address _trio, address _fundingSource) public {\n        team = Team(_m0, _m1, _m2, _m3);\n        percentages[_m0] = 440;\n        percentages[_m1] = 250;\n        percentages[_m2] = 186;\n        percentages[_m3] = 124;\n\n        tripio = TripioToken(_trio);\n        fundingSource = _fundingSource;\n\n        enabled = true;\n        \n        // All timestamps from 2019-06-01 to 2021-05-01\n        timestamps.push(1559361600); // 2019-06-01\t12:00 \n        timestamps.push(1561953600); // 2019-07-01\t12:00 \n        timestamps.push(1564632000); // 2019-08-01\t12:00 \n        timestamps.push(1567310400); // 2019-09-01\t12:00 \n        timestamps.push(1569902400); // 2019-10-01\t12:00 \n        timestamps.push(1572580800); // 2019-11-01\t12:00\n        timestamps.push(1575172800); // 2019-12-01\t12:00\n        timestamps.push(1577851200); // 2020-01-01\t12:00\n        timestamps.push(1580529600); // 2020-02-01\t12:00\n        timestamps.push(1583035200); // 2020-03-01\t12:00\n        timestamps.push(1585713600); // 2020-04-01\t12:00\n        timestamps.push(1588305600); // 2020-05-01\t12:00\n        timestamps.push(1590984000); // 2020-06-01\t12:00\n        timestamps.push(1593576000); // 2020-07-01\t12:00\n        timestamps.push(1596254400); // 2020-08-01\t12:00\n        timestamps.push(1598932800); // 2020-09-01\t12:00\n        timestamps.push(1601524800); // 2020-10-01\t12:00\n        timestamps.push(1604203200); // 2020-11-01\t12:00\n        timestamps.push(1606795200); // 2020-12-01\t12:00\n        timestamps.push(1609473600); // 2021-01-01\t12:00\n        timestamps.push(1612152000); // 2021-02-01\t12:00\n        timestamps.push(1614571200); // 2021-03-01\t12:00\n        timestamps.push(1617249600); // 2021-04-01\t12:00\n        timestamps.push(1619841600); // 2021-05-01\t12:00\n    }\n\n    /**\n     * Only member\n     */\n    modifier onlyMember {\n        require(team.m0 == msg.sender || team.m1 == msg.sender || team.m2 == msg.sender || team.m3 == msg.sender, \"Only member\");\n        _;\n    }\n\n    /**\n     * Only owner or members\n     */\n    modifier onlyOwnerOrMember {\n        require(msg.sender == owner || team.m0 == msg.sender || team.m1 == msg.sender || team.m2 == msg.sender || team.m3 == msg.sender, \"Only member\");\n        _;\n    }\n\n    function _withdraw() private {\n        uint256 tokens = tripio.balanceOf(address(this));\n        tripio.transfer(fundingSource, tokens);\n    }\n\n    /**\n     * query the proposal by proposalLength\n     */\n    function teamProposal(uint256 _proposalIndex) external view returns(\n        address _sponsor,\n        bool[] memory _signatures,\n        uint256 _timestamp,\n        uint8 _proposalType,\n        uint16[] memory _percentages,\n        address[] memory _members,\n        uint8 _status,\n        bool _terminal\n    ) {\n        Proposal storage proposal = proposalMap[_proposalIndex];\n        mapping (address =\u003e bool) storage signatures = proposal.signatures;\n        _signatures = new bool[](4);\n        _percentages = new uint16[](4);\n        _members = new address[](4);\n\n        _sponsor = proposal.sponsor;\n        _signatures[0] = signatures[team.m0];\n        _signatures[1] = signatures[team.m1];\n        _signatures[2] = signatures[team.m2];\n        _signatures[3] = signatures[team.m3];\n        _timestamp = proposal.timestamp;\n        _proposalType = proposal.proposalType;\n\n        if (_proposalType == 1) {  \n            _percentages[0] = suggestedPercentagesMap[_proposalIndex][team.m0];\n            _percentages[1] = suggestedPercentagesMap[_proposalIndex][team.m1];\n            _percentages[2] = suggestedPercentagesMap[_proposalIndex][team.m2];\n            _percentages[3] = suggestedPercentagesMap[_proposalIndex][team.m3];\n        } else if (_proposalType == 2) {\n            _members[0] = suggestedTeamMap[_proposalIndex].m0;\n            _members[1] = suggestedTeamMap[_proposalIndex].m1;\n            _members[2] = suggestedTeamMap[_proposalIndex].m2;\n            _members[3] = suggestedTeamMap[_proposalIndex].m3;\n        } else if (_proposalType == 3) {\n            _status = suggestStatusMap[_proposalIndex];\n        } else if (_proposalType == 4) {\n            _terminal = suggestTerminalMap[_proposalIndex];\n        }\n\n    }\n\n    /**\n     * Current percentages\n     */\n    function teamPercentages() external view returns(uint16[] memory _percentages) {\n        _percentages = new uint16[](4);\n        _percentages[0] = percentages[team.m0];\n        _percentages[1] = percentages[team.m1];\n        _percentages[2] = percentages[team.m2];\n        _percentages[3] = percentages[team.m3];\n    }\n\n    /**\n     * Current members\n     */\n    function teamMembers() external view returns(address[] memory _members) {\n        _members = new address[](4);\n        _members[0] = team.m0;\n        _members[1] = team.m1;\n        _members[2] = team.m2;\n        _members[3] = team.m3;\n    }\n\n    /**\n     * All schedules \n     */\n    function teamTimestamps() external view returns(uint256[] memory _timestamps) {\n        _timestamps = new uint256[](timestamps.length);\n        for(uint256 i = 0; i \u003c timestamps.length; i++) {\n            _timestamps[i] = timestamps[i];\n        }\n    }\n\n    /**\n     * Record fund reserve\n     */\n    function deposit() external returns(bool) {\n        require (msg.sender == fundingSource, \"msg.sender must be fundingSource\");\n        uint256 value = tripio.allowance(msg.sender, address(this));\n        require(value \u003e 0, \"Value must more than 0\");\n        tripio.transferFrom(msg.sender, address(this), value);\n        \n        // Event\n        emit Deposited(msg.sender, value);\n    }\n\n    /**\n     * Make a proposal for updating percentages\n     */\n    function vote (address _sponsor, uint256 _proposalIndex, uint _proposalType) external onlyMember {\n        Proposal storage proposal = proposalMap[_proposalIndex];\n        require (proposal.sponsor == _sponsor \u0026\u0026 proposal.proposalType == _proposalType, \"proposal check fail\");\n        require (proposal.timestamp + 2 days \u003e now, \"Expired proposal\");\n\n        proposal.signatures[msg.sender] = true;\n       \n        if (_proposalType == 1) {\n            _updatePercentages(_proposalIndex);\n        }\n        if (_proposalType == 2) {\n            _updateMembers(_proposalIndex);\n        }\n        if (_proposalType == 3) {\n            _updateStatus(_proposalIndex);\n        }\n        if (_proposalType == 4) {\n            _terminate(_proposalIndex);\n        }\n\n        emit Vote(msg.sender, _proposalIndex);\n    }\n\n    /**\n     * check if 3/4 agree\n     */\n    function _isThreeQuarterAgree (Proposal storage _proposal) private view returns (bool res) {\n        mapping (address =\u003e bool) storage signatures = _proposal.signatures;\n        return (\n            (signatures[team.m0] \u0026\u0026 signatures[team.m1] \u0026\u0026 signatures[team.m2])\n            || (signatures[team.m0] \u0026\u0026 signatures[team.m2] \u0026\u0026 signatures[team.m3])\n            || (signatures[team.m1] \u0026\u0026 signatures[team.m2] \u0026\u0026 signatures[team.m3])\n        );\n    }\n\n    /**\n     * check if 4/4 agree\n     */\n    function _isAllAgree (Proposal storage _proposal) private view returns (bool res) {\n        mapping (address =\u003e bool) storage signatures = _proposal.signatures;\n        return signatures[team.m0] \u0026\u0026 signatures[team.m1] \u0026\u0026 signatures[team.m2] \u0026\u0026 signatures[team.m3];\n    }\n\n    function _createProposal (uint8 _proposalType) private {\n        Proposal storage proposal = proposalMap[proposalLength];\n        proposal.sponsor = msg.sender;\n        proposal.signatures[msg.sender] = true;\n        proposal.timestamp = now;\n        proposal.proposalType = _proposalType;\n        proposalLength += 1;\n    }\n\n    /**\n     * Make a proposal for updating percentages\n     */\n    function updatePercentagesProposal(uint16 _m0, uint16 _m1, uint16 _m2, uint16 _m3) external onlyMember {\n        require (_m0 + _m1 + _m2 + _m3 == 1000, \"the sum must be 1000\");   \n        mapping (address =\u003e uint16) storage suggestedPercentage = suggestedPercentagesMap[proposalLength];\n        \n        suggestedPercentage[team.m0] = _m0;\n        suggestedPercentage[team.m1] = _m1;\n        suggestedPercentage[team.m2] = _m2;\n        suggestedPercentage[team.m3] = _m3;\n\n        _createProposal(1);\n        // Event\n        emit PercentagesProposalMade(msg.sender, now, _m0, _m1, _m2, _m3);\n    }\n\n    function _updatePercentages (uint256 _proposalIndex) private {\n        if (_isAllAgree(proposalMap[_proposalIndex])) {        \n            percentages[team.m0] = suggestedPercentagesMap[_proposalIndex][team.m0];\n            percentages[team.m1] = suggestedPercentagesMap[_proposalIndex][team.m1];\n            percentages[team.m2] = suggestedPercentagesMap[_proposalIndex][team.m2];\n            percentages[team.m3] = suggestedPercentagesMap[_proposalIndex][team.m3];\n            emit PercentagesUpdated(percentages[team.m0], percentages[team.m1], percentages[team.m2], percentages[team.m3]);\n        }\n    }\n\n    /**\n     * Update the team members, need all memebers\u0027s signatures\n     */\n    function updateMembersProposal(address _m0, address _m1, address _m2, address _m3) external onlyMember {\n        require (_m0 != address(0) \u0026\u0026 _m1 != address(0) \u0026\u0026 _m2 != address(0) \u0026\u0026 _m3 != address(0), \"invalid addresses\");\n        Team storage suggestedTeam = suggestedTeamMap[proposalLength];\n\n        suggestedTeam.m0 = _m0;\n        suggestedTeam.m1 = _m1;\n        suggestedTeam.m2 = _m2;\n        suggestedTeam.m3 = _m3;\n\n        _createProposal(2);\n        // Event\n        emit MembersProposalMade(msg.sender, now, _m0, _m1, _m2, _m3);\n    }\n\n    function _updateMembers (uint256 _proposalIndex) private {\n        if (_isAllAgree(proposalMap[_proposalIndex])) {\n            Team memory newTeam = Team(\n                suggestedTeamMap[_proposalIndex].m0,\n                suggestedTeamMap[_proposalIndex].m1,\n                suggestedTeamMap[_proposalIndex].m2,\n                suggestedTeamMap[_proposalIndex].m3\n            );\n            percentages[newTeam.m0] = percentages[team.m0];\n            percentages[newTeam.m1] = percentages[team.m1];\n            percentages[newTeam.m2] = percentages[team.m2];\n            percentages[newTeam.m3] = percentages[team.m3];\n\n            team = newTeam;\n            emit MembersUpdated(team.m0, team.m1, team.m2, team.m3);\n        }\n    }\n\n    /**\n     * Update the contract status, enable for 1 or disable for 2\n     */\n    function updateStatusProposal(uint8 _status) external onlyMember {\n        require (_status == 1 || _status == 2, \"must be one of 1 and 2\");\n\n        suggestStatusMap[proposalLength] = _status;\n        _createProposal(3);\n        // Event\n        emit StatusProposalMade(msg.sender, now, _status);\n    }\n\n    function _updateStatus(uint256 _proposalIndex) private {\n        if (_isThreeQuarterAgree(proposalMap[_proposalIndex])) {        \n            if (suggestStatusMap[_proposalIndex] == 1) {\n                enabled = true;               \n                // restart and reset timestamps\n                for(uint256 i = 0; i \u003c timestamps.length; i++) {\n                    if(timestamps[i] != 0 \u0026\u0026 timestamps[i] \u003c now) {\n                        timestamps[i] = 0;\n                    }\n                }\n            } else if (suggestStatusMap[_proposalIndex] == 2) {\n                enabled = false;\n            }\n\n            // Event\n            emit StatusUpdated(suggestStatusMap[_proposalIndex]);\n        }\n    }\n\n    /**\n     * Terminate the contract\n     * the remaining candy will transfer to the original owner\n     * _terminal cant be false\n     */\n    function terminateProposal(bool _terminal) external onlyMember {\n        require (_terminal, \"must true\");\n\n        suggestTerminalMap[proposalLength] = _terminal;\n        _createProposal(4);\n        // Event\n        emit TerminalProposalMade(msg.sender, now, _terminal);\n    }\n\n    function _terminate(uint256 _proposalIndex) private {\n        if (_isAllAgree(proposalMap[_proposalIndex])) {        \n            _withdraw();\n\n            // Event\n            emit Terminated();\n        }\n    }\n\n    /**\n     * Candy every month\n     */\n    function candy() external onlyOwnerOrMember {\n        require(enabled, \"Must enabled\");\n        // Remaining tokens\n        uint256 tokens = tripio.balanceOf(address(this));\n        uint256 count = 0;\n        for(uint256 i = 0; i \u003c timestamps.length; i++) {\n            if(timestamps[i] != 0) {\n                count++;\n            }\n        }\n        require(tokens \u003e count \u0026\u0026 count \u003e 0, \"tokens should be larger than count\");\n\n        uint256 token0 = tokens * percentages[team.m0]/1000/count;\n        uint256 token1 = tokens * percentages[team.m1]/1000/count;\n        uint256 token2 = tokens * percentages[team.m2]/1000/count;\n        uint256 token3 = tokens * percentages[team.m3]/1000/count;\n\n        uint256 enabledCount = 0;\n        for(uint256 i = 0; i \u003c timestamps.length; i++) {\n            if(timestamps[i] != 0 \u0026\u0026 timestamps[i] \u003c= now) {\n                enabledCount++;\n                if(token0 \u003e 0) {\n                    tripio.transfer(team.m0, token0);\n                    tokens -= token0;\n                }\n                if(token1 \u003e 0) {\n                    tripio.transfer(team.m1, token1);\n                    tokens -= token1;\n                }\n                if(token2 \u003e 0) {\n                    tripio.transfer(team.m2, token2);\n                    tokens -= token2;\n                }\n                if(token3 \u003e 0) {\n                    tripio.transfer(team.m3, token3);\n                    tokens -= token3;\n                }\n                timestamps[i] = 0;\n            }\n        }\n        require(enabledCount \u003e 0, \"enabledCount cant be zero\");\n\n        if(count == 1 \u0026\u0026 tokens \u003e 0) {\n            // withdraw the remaining candy\n            _withdraw();\n        }\n\n        // Event\n        emit Candy();\n    }\n}"},"Owned.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * Owned contract\n */\ncontract Owned {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipTransferred(address indexed from, address indexed to);\n\n    /**\n     * Constructor\n     */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Only the owner of contract\n     */ \n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n    \n    /**\n     * @dev transfer the ownership to other\n     *      - Only the owner can operate\n     */ \n    function transferOwnership(address _newOwner) public onlyOwner {\n        newOwner = _newOwner;\n    }\n\n    /** \n     * @dev Accept the ownership from last owner\n     */ \n    function acceptOwnership() public {\n        require(msg.sender == newOwner, \"Only new owner\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}"},"TripioToken.sol":{"content":"pragma solidity ^0.5.0;\n\ncontract TripioToken {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    function transfer(address _to, uint256 _value) public returns (bool);\n    function balanceOf(address who) public view returns (uint256);\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n    function approve(address _spender, uint256 _value) public returns (bool);\n    function allowance(address owner, address spender) public view returns (uint256);\n}"}}