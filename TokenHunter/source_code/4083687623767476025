{"IERC20.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * Open Zeppelin ERC20 implementation. https://github.com/OpenZeppelin/openzeppelin-solidity/tree/master/contracts/token/ERC20\n */\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * \u003e Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"SmartInvoice.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\n\ncontract SmartInvoice {\n    enum Status { UNCOMMITTED, COMMITTED, SETTLED }\n    function getStatusString(Status status)\n    public\n    pure\n    returns (string memory)\n    {\n        if (Status.UNCOMMITTED == status) {\n            return \"UNCOMMITTED\";\n        }\n        if (Status.COMMITTED == status) {\n            return \"COMMITTED\";\n        }\n        if (Status.SETTLED == status) {\n            return \"SETTLED\";\n        }\n        return \"ERROR\";\n    }\n\n    uint256 public amount;\n    uint256 public dueDate;\n    IERC20 public assetToken;\n    address public beneficiary;\n    address public payer;\n    string public referenceHash;\n\n    Status  public status;\n\n    /**\n     * @dev Constructor that gives msg.sender all of existing tokens.\n     */\n    constructor(uint256 _amount,\n                uint256 _dueDate,\n                IERC20 _assetToken,\n                address _beneficiary,\n                address _payer,\n                string memory _referenceHash) public {\n        require(_beneficiary != address(0), \"beneficiary cannot be 0x0\");\n        require(_payer != address(0), \"payer cannot be 0x0\");\n        amount = _amount;\n        dueDate = _dueDate;\n        assetToken = _assetToken;\n        beneficiary = _beneficiary;\n        payer = _payer;\n        referenceHash = _referenceHash;\n\n        status = Status.UNCOMMITTED;\n    }\n\n    function changeBeneficiary(address _newBeneficiary) public returns (bool) {\n        require(msg.sender == beneficiary, \"caller not current beneficiary\");\n        require(_newBeneficiary != address(0), \"new beneficiary cannot be 0x0\");\n        require(status != Status.SETTLED, \"can not change beneficiary after settlement\");\n        beneficiary = _newBeneficiary;\n        return true;\n    }\n\n    function commit() public returns (bool) {\n        require(msg.sender == payer, \"only payer can commit to settle\");\n        require(status == Status.UNCOMMITTED, \"can only commit while status in UNCOMMITTED\");\n        status = Status.COMMITTED;\n        return true;\n    }\n\n    function settle() public returns (bool) {\n        require(msg.sender == payer, \"only payer can settle\");\n        require(status != Status.SETTLED, \"already settled\");\n        require(now \u003e= dueDate, \"can only settle after due date\");\n        require(assetToken.transferFrom(payer, beneficiary, amount), \"could not complete transfer\");\n        status = Status.SETTLED;\n        return true;\n    }\n\n}\n\n"}}