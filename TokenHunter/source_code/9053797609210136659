{"Administrable.sol":{"content":"pragma solidity ^0.5.16;\n\nimport \"./Ownable.sol\";\n\n\ncontract Administrable is Ownable {\n    event AdminstratorAdded(address adminAddress);\n    event AdminstratorRemoved(address adminAddress);\n\n    mapping (address =\u003e bool) public administrators;\n\n    modifier onlyAdministrator() {\n        require(administrators[msg.sender] || owner == msg.sender); // owner is an admin by default\n        _;\n    }\n\n    /// @notice Add an administrator\n    /// @param _adminAddress The new administrator address\n    function addAdministrators(address _adminAddress) public onlyOwner {\n        administrators[_adminAddress] = true;\n        emit AdminstratorAdded(_adminAddress);\n        return;\n    }\n\n    /// @notice Remove an administrator\n    /// @param _adminAddress The administrator address to remove\n    function removeAdministrators(address _adminAddress) public onlyOwner {\n        delete administrators[_adminAddress];\n        emit AdminstratorRemoved(_adminAddress);\n        return;\n    }\n}\n"},"GimblChallenge.sol":{"content":"pragma solidity ^0.5.16;\n\nimport \"./Administrable.sol\";\nimport \"./GIMTokenInterface.sol\";\n\ncontract SafeMath {\n  function safeMul(uint a, uint b) pure internal returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function safeDiv(uint a, uint b) pure internal returns (uint) {\n    assert(b \u003e 0);\n    uint c = a / b;\n    assert(a == b * c + a % b);\n    return c;\n  }\n\n  function safeSub(uint a, uint b) pure internal returns (uint) {\n    assert(b \u003c= a);\n    return a - b;\n  }\n}\n\ncontract GimblChallenge is SafeMath, Administrable {\n  enum ChallengeStatus { CREATED, ACHIEVED, FAILED }\n  enum Currency { ETH, GIM }\n\n  struct Challenge {\n    address payable challenger;\n    address payable challenged;\n    uint256 amount;\n    Currency currency;\n    ChallengeStatus status;\n    uint256 gimblFeesPpm;\n    uint256 gimblFees;\n  }\n  mapping (uint256 =\u003e Challenge) challenges;\n  uint256 public challengeCount;\n  uint256 public minimumETHChallengeAmount;\n  uint256 public minimumGIMChallengeAmount;\n  GIMTokenInterface gimToken;\n\n  event ChallengeCreated(uint256 challengeIndex);\n  event ChallengeResolved(uint256 challengeIndex);\n\n  constructor(uint256 _minimumETHChallengeAmount, uint256 _minimumGIMChallengeAmount, address _gimTokenAddress) public {\n    minimumETHChallengeAmount = _minimumETHChallengeAmount;\n    minimumGIMChallengeAmount = _minimumGIMChallengeAmount;\n    gimToken = GIMTokenInterface(_gimTokenAddress);\n  }\n\n  function updateMinimumChallengeAmounts(uint256 _minimumETHChallengeAmount, uint256 _minimumGIMChallengeAmount) public onlyOwner {\n    minimumETHChallengeAmount = _minimumETHChallengeAmount;\n    minimumGIMChallengeAmount = _minimumGIMChallengeAmount;\n  }\n\n  function createETHChallenge(address payable _challenged, uint256 _gimblFeesPpm) public payable {\n    require(_challenged != msg.sender);\n    require(msg.value \u003e= minimumETHChallengeAmount);\n\n    challenges[challengeCount].challenger = msg.sender;\n    challenges[challengeCount].challenged = _challenged;\n    challenges[challengeCount].amount = msg.value;\n    challenges[challengeCount].currency = Currency.ETH;\n    challenges[challengeCount].gimblFeesPpm = _gimblFeesPpm;\n\n    emit ChallengeCreated(challengeCount);\n    challengeCount += 1;\n  }\n\n  function createGIMChallenge(address payable _challenged, uint256 _gimblFeesPpm, uint256 _amount) public {\n    require(_challenged != msg.sender);\n    require(_amount \u003e= minimumGIMChallengeAmount);\n\n    require(gimToken.transferGIM(msg.sender, address(this), _amount));\n\n    challenges[challengeCount].challenger = msg.sender;\n    challenges[challengeCount].challenged = _challenged;\n    challenges[challengeCount].amount = _amount;\n    challenges[challengeCount].currency = Currency.GIM;\n    challenges[challengeCount].gimblFeesPpm = _gimblFeesPpm;\n\n    emit ChallengeCreated(challengeCount);\n    challengeCount += 1;\n  }\n\n  function resolveChallenge(uint256 _challengeIndex, bool _achieved) public onlyAdministrator {\n    Challenge storage challenge = challenges[_challengeIndex];\n    require(_challengeIndex \u003c challengeCount \u0026\u0026 challenge.status == ChallengeStatus.CREATED);\n\n    if (_achieved) {\n      challenge.status = ChallengeStatus.ACHIEVED;\n      challenge.gimblFees = safeDiv(safeMul(challenge.gimblFeesPpm, challenge.amount), 10 ** 3);\n      if (challenge.currency == Currency.ETH) {\n        challenge.challenged.transfer(safeSub(challenge.amount, challenge.gimblFees));\n        owner.transfer(challenge.gimblFees);\n      } else {\n        gimToken.transfer(challenge.challenged, safeSub(challenge.amount, challenge.gimblFees));\n        gimToken.transfer(owner, challenge.gimblFees);\n      }\n    } else {\n      challenge.status = ChallengeStatus.FAILED;\n      if (challenge.currency == Currency.ETH) {\n        challenge.challenger.transfer(challenge.amount);\n      } else {\n        gimToken.transfer(challenge.challenger, challenge.amount);\n      }\n    }\n\n    emit ChallengeResolved(_challengeIndex);\n  }\n\n  function getChallenge(uint256 _challengeIndex) public view returns (address challenger, address challenged, uint256 amount, Currency currency, uint256 status, uint256 gimblFeesPpm, uint256 gimblFees){\n    Challenge storage c = challenges[_challengeIndex];\n    return (c.challenger, c.challenged, c.amount, c.currency, uint256(c.status), c.gimblFeesPpm, c.gimblFees);\n  }\n}\n"},"GIMTokenInterface.sol":{"content":"pragma solidity ^0.5.16;\n\ninterface GIMTokenInterface {\n  function transfer(address, uint256) external returns (bool);\n  function transferGIM(address, address, uint256) external returns (bool);\n}\n"},"Ownable.sol":{"content":"pragma solidity ^0.5.16;\n\n\ncontract Ownable {\n    address payable public owner;\n    address payable public newOwner;\n\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /// @notice Transfer ownership from `owner` to `newOwner`\n    /// @param _newOwner The new contract owner\n    function transferOwnership(address payable _newOwner) public onlyOwner {\n        if (_newOwner != address(0)) {\n            newOwner = _newOwner;\n        }\n        return;\n    }\n\n    /// @notice accept ownership of the contract\n    function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n}\n"}}